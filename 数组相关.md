***
#### 题目
##### 283. 移动零
#### 地址
##### https://leetcode-cn.com/problems/move-zeroes/
#### 方法一：双指针
##### 复杂度分析
###### 时间复杂度：O(n)
###### 空间复杂度：O(1)
##### Golang实现
    func moveZeroes(nums []int) {
    	for i, j := 0, 0; i < len(nums); i++ {
    		if nums[i] != 0 {
    			nums[j], nums[i] = nums[i], nums[j]
    			j++
    		}
    	}
    }
***
#### 题目
##### 15. 三数之和
#### 地址
##### https://leetcode-cn.com/problems/3sum/
#### 方法一：双指针
##### 复杂度分析
###### 时间复杂度：O(n^2)
###### 空间复杂度：O(n)
##### Golang实现
    func threeSum(nums []int) [][]int {
        ret := make([][]int, 0)
    
        sort.Ints(nums)
        for k := 0; k < len(nums)-2; k++ {
            // 如果固定位的值已经大于0，因为已经排好序了，后面的两个指针对应的值也肯定大于0，则和不可能为0，所以返回
            if nums[k] > 0 {
                return ret
            }
            // 排除值重复的固定位
            if k > 0 && nums[k] == nums[k-1] {
                continue
            }
            // 开始移动两个指针
            for i, j := k+1, len(nums)-1; i < j; {
                // 判断三个数字之和的三种情况
                sum := nums[k] + nums[i] + nums[j]
                if sum == 0 {
                    // 将结果加入二维切片
                    ret = append(ret, []int{nums[k], nums[i], nums[j]})
                    // 去重，如果i < j且下一个数字一样，则继续挪动
                    for i < j && nums[i] == nums[i+1] {
                        i++
                    }
                    // 同理
                    for i < j && nums[j] == nums[j-1] {
                        j--
                    }
                    i++
                    j--
                } else if sum > 0 {
                    // 如果和大于 0，那就说明 right 的值太大，需要左移
                    j--
                } else {
                    // 如果和小于 0，那就说明 left 的值太小，需要右移
                    i++
                }
            }
        }
    
        return ret
    }
***
#### 题目
##### 989. 数组形式的整数加法
#### 地址
##### https://leetcode-cn.com/problems/add-to-array-form-of-integer/
#### 方法一：遍历进位（整除、取余）
##### 复杂度分析
###### 时间复杂度：O(n)
###### 空间复杂度：O(n)
##### Golang实现
    func addToArrayForm(A []int, K int) []int {
    	ret := make([]int, 0)
    
    	for i := len(A) - 1; i >= 0 || K > 0; i-- {
    		temp := 0
    		if i >= 0 {
    			temp = A[i] + K
    		} else {
    			temp = K
    		}
    
    		ret = append(ret, temp%10)
    		K = temp / 10
    	}
    
    	return reverse(ret)
    }
    
    func reverse(ret []int) []int {
    	for i, j := 0, len(ret)-1; i < j; i, j = i+1, j-1 {
    		ret[i], ret[j] = ret[j], ret[i]
    	}
    
    	return ret
    }
***
#### 题目
##### 1734. 解码异或后的排列
#### 地址
##### https://leetcode-cn.com/problems/decode-xored-permutation/
#### 方法一：二进制异或知识点
##### 复杂度分析
###### 时间复杂度：O(n)
###### 空间复杂度：O(n)
##### Golang实现
    // ^ 相同为0 不同为1
    // A ^ A = 0
    // 0 ^ A = A
    // A ^ B = C 等价于 A ^ C = B
    func decode(encoded []int) []int {
    	n := len(encoded)
    	ret := make([]int, n+1)
    
    	for i := 1; i <= n+1; i++ {
    		ret[0] ^= i
    		if i < n && i%2 == 1 {
    			ret[0] ^= encoded[i]
    		}
    	}
    
    	for i := 0; i < n; i++ {
    		ret[i+1] = ret[i] ^ encoded[i]
    	}
    
    	return ret
    }
***
#### 题目
##### 1672. 最富有客户的资产总量
#### 地址
##### https://leetcode-cn.com/problems/richest-customer-wealth/
#### 方法一：遍历
##### 复杂度分析
###### 时间复杂度：O(n^2)
###### 空间复杂度：O(1)
##### Golang实现
    func maximumWealth(accounts [][]int) int {
    	max := 0
    
    	for _, account := range accounts {
    		count := 0
    		for _, num := range account {
    			count += num
    		}
    
    		if max < count {
    			max = count
    		}
    	}
    
    	return max
    }
***
#### 题目
##### 66. 加一
#### 地址
##### https://leetcode-cn.com/problems/plus-one/
#### 方法一：遍历
##### 复杂度分析
###### 时间复杂度：O(n)
###### 空间复杂度：O(n)
##### Golang实现
    func plusOne(digits []int) []int {
        for i := len(digits)-1; i >= 0; i-- {
            if digits[i] < 9 {
                digits[i]++
                return digits
            }
    
            digits[i] = 0
        }
    
        ret := make([]int, len(digits)+1)
        ret[0] = 1
    
        return ret
    }
***
#### 题目
##### 122. 买卖股票的最佳时机 II
#### 地址
##### https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/
#### 方法一：双指针
##### 复杂度分析
###### 时间复杂度：O(N)，这里 N 表示股价数组的长度
###### 空间复杂度：O(1)
##### Golang实现
    func maxProfit(prices []int) int {
    	max := 0
    
    	for i, j := 0, 1; i < j && j < len(prices); {
    		if prices[i] >= prices[j] {
    			i++
    			j++
    		} else if j == len(prices)-1 {
    			max += prices[j] - prices[i]
                break
    		} else if prices[j] > prices[j+1] {
    			max += prices[j] - prices[i]
    			i = j + 1
    			j = i + 1
    		} else {
    			j++
    		}
    	}
    
    	return max
    }
#### 方法二：动态规划
##### 复杂度分析
###### 时间复杂度：O(N)，这里 N 表示股价数组的长度
###### 空间复杂度：O(N)
##### Golang实现
    func maxProfit(prices []int) int {
    	n := len(prices)
    	dp := make([][2]int, n)
    	dp[0][1] = -prices[0]
        
    	for i := 1; i < n; i++ {
    		dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
    		dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])
    	}
    
    	return dp[n-1][0]
    }
    
    func max(a, b int) int {
    	if a > b {
    		return a
    	}
    
    	return b
    }
#### 方法三：动态规划（空间优化）
##### 复杂度分析
###### 时间复杂度：O(N)，这里 N 表示股价数组的长度
###### 空间复杂度：O(1)
##### Golang实现
    func maxProfit(prices []int) int {
    	dp0, dp1 := 0, -prices[0]
    
    	for i := 1; i < len(prices); i++ {
    		dp0, dp1 = max(dp0, dp1+prices[i]), max(dp1, dp0-prices[i])
    	}
    
    	return dp0
    }
    
    func max(a, b int) int {
    	if a > b {
    		return a
    	}
    
    	return b
    }
#### 方法四：贪心
##### 复杂度分析
###### 时间复杂度：O(N)，这里 N 表示股价数组的长度
###### 空间复杂度：O(1)
##### Golang实现
    func maxProfit(prices []int) int {
    	ret := 0
    
    	for i := 1; i < len(prices); i++ {
    		ret += max(0, prices[i]-prices[i-1])
    	}
    
        return ret
    }
    
    func max(a, b int) int {
    	if a > b {
    		return a
    	}
    
    	return b
    }
***
#### 题目
##### 11. 盛最多水的容器
#### 地址
##### https://leetcode-cn.com/problems/container-with-most-water/
#### 方法一：双指针左右夹逼法
##### 复杂度分析
###### 时间复杂度：O(n)
###### 空间复杂度：O(1)
##### Golang实现
    func maxArea(height []int) int {
    	ret := 0
    
    	for i, j := 0, len(height)-1; i < j; {
    		if height[i] < height[j] {
    			ret = max(ret, (j-i)*height[i])
    			i++
    		} else {
    			ret = max(ret, (j-i)*height[j])
    			j--
    		}
    	}
    
    	return ret
    }
    
    func max(a, b int) int {
    	if a > b {
    		return a
    	}
    
    	return b
    }
***
#### 题目
##### 867. 转置矩阵
#### 地址
##### https://leetcode-cn.com/problems/transpose-matrix/
#### 方法一：遍历
##### 复杂度分析
###### 时间复杂度：O(mn)，其中 m 和 n 分别是矩阵 matrix 的行数和列数。需要遍历整个矩阵，并对转置后的矩阵进行赋值操作。
###### 空间复杂度：O(n) n 是矩阵 matrix 的列数。
##### Golang实现
    func transpose(matrix [][]int) [][]int {
    	ret := make([][]int, len(matrix[0]))
    
        for _, m := range matrix {
    		for i := 0; i < len(m); i++ {
    			ret[i] = append(ret[i], m[i])
    		}
        }
    
        return ret
    }
##### C++实现
    class Solution
    {
    public:
        vector<vector<int> > transpose(vector<vector<int> > &matrix)
        {
            int m = matrix.size();
            int n = matrix[0].size();
            vector<vector<int> > res(n, vector<int>(m));
    
            for (int i = 0; i < m; i++) 
            {
                for (int j = 0; j < n; j++) {
                    res[j][i] = matrix[i][j];
                }
            }
    
            return res;        
        }
    };
***