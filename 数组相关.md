***
#### 题目
##### 283. 移动零
#### 地址
##### https://leetcode-cn.com/problems/move-zeroes/
#### 方法一：双指针
##### 复杂度分析
###### 时间复杂度：O(n)
###### 空间复杂度：O(1)
##### Golang实现
    func moveZeroes(nums []int) {
    	for i, j := 0, 0; i < len(nums); i++ {
    		if nums[i] != 0 {
    			nums[j], nums[i] = nums[i], nums[j]
    			j++
    		}
    	}
    }
***
#### 题目
##### 15. 三数之和
#### 地址
##### https://leetcode-cn.com/problems/3sum/
#### 方法一：双指针
##### 复杂度分析
###### 时间复杂度：O(n^2)
###### 空间复杂度：O(n)
##### Golang实现
    func threeSum(nums []int) [][]int {
        ret := make([][]int, 0)
    
        sort.Ints(nums)
        for k := 0; k < len(nums)-2; k++ {
            // 如果固定位的值已经大于0，因为已经排好序了，后面的两个指针对应的值也肯定大于0，则和不可能为0，所以返回
            if nums[k] > 0 {
                return ret
            }
            // 排除值重复的固定位
            if k > 0 && nums[k] == nums[k-1] {
                continue
            }
            // 开始移动两个指针
            for i, j := k+1, len(nums)-1; i < j; {
                // 判断三个数字之和的三种情况
                sum := nums[k] + nums[i] + nums[j]
                if sum == 0 {
                    // 将结果加入二维切片
                    ret = append(ret, []int{nums[k], nums[i], nums[j]})
                    // 去重，如果i < j且下一个数字一样，则继续挪动
                    for i < j && nums[i] == nums[i+1] {
                        i++
                    }
                    // 同理
                    for i < j && nums[j] == nums[j-1] {
                        j--
                    }
                    i++
                    j--
                } else if sum > 0 {
                    // 如果和大于 0，那就说明 right 的值太大，需要左移
                    j--
                } else {
                    // 如果和小于 0，那就说明 left 的值太小，需要右移
                    i++
                }
            }
        }
    
        return ret
    }
***