***
#### 题目
##### 剑指 Offer 49. 丑数
#### 地址
##### https://leetcode-cn.com/problems/chou-shu-lcof/
#### 方法一：动态规划
##### 复杂度分析
###### 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
###### 空间复杂度：O(N) 长度为 N 的 dp 列表使用 O(N) 的额外空间。
##### Golang实现
    func nthUglyNumber(n int) int {
        ret := make([]int, n)
        ret[0] = 1
        i2, i3, i5 := 0, 0, 0
    
        for i := 1; i < n; i++ {
            ret[i] = min(ret[i2]*2, min(ret[i3]*3, ret[i5]*5))
    
            if ret[i] == ret[i2]*2 {
                i2++
            }
            if ret[i] == ret[i3]*3 {
                i3++
            }
            if ret[i] == ret[i5]*5 {
                i5++
            }
        }
    
        return ret[n-1]
    }
    
    func min(a, b int) int {
        if a > b {
            return b
        }
    
        return a
    }
***
#### 题目
##### 面试题 17.09. 第 k 个数
#### 地址
##### https://leetcode-cn.com/problems/get-kth-magic-number-lcci/
#### 方法一：动态规划
##### 复杂度分析
###### 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
###### 空间复杂度：O(N) 长度为 N 的 dp 列表使用 O(N) 的额外空间。
##### Golang实现
    func getKthMagicNumber(k int) int {
        ret := make([]int, k)
        ret[0] = 1
        i3, i5, i7 := 0, 0, 0
    
        for i := 1; i < k; i++ {
            ret[i] = min(ret[i3]*3, min(ret[i5]*5, ret[i7]*7))
    
            if ret[i] == ret[i3]*3 {
                i3++
            }
            if ret[i] == ret[i5]*5 {
                i5++
            }
            if ret[i] == ret[i7]*7 {
                i7++
            }
        }
    
        return ret[k-1]
    }
    
    func min(a, b int) int {
        if a > b {
            return b
        }
    
        return a
    }
***
#### 题目
##### 70. 爬楼梯
#### 地址
##### https://leetcode-cn.com/problems/climbing-stairs/
#### 方法一：数学公式（斐波那契数列的公式）
##### 复杂度分析
###### 时间复杂度：O(log(n))。
###### 空间复杂度：O(1)。
##### Golang实现
    func climbStairs(n int) int {
        sqrt5 := math.Sqrt(5)
        fibN := math.Pow((1+sqrt5)/2, float64(n+1)) - math.Pow((1-sqrt5)/2, float64(n+1))
        return int(math.Round(fibN / sqrt5))
    }
#### 方法二：动态规划（斐波拉契数列 F(n) = F(n-1) + F(n-2) (n>=2, F(0) = 0, F(1) = 1)）
##### 复杂度分析
###### 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
###### 空间复杂度：O(N) 长度为 N 的 dp 列表使用 O(N) 的额外空间。
##### Golang实现
    func climbStairs(n int) int {
        if n <= 2 {
            return n
        }
    
        ret := make([]int, n)
        ret[0] = 1
        ret[1] = 2
        for i := 2; i < n; i++ {
            ret[i] = ret[i-1] + ret[i-2]
        }
    
        return ret[n-1]
    }
#### 方法三：动态规划，空间复杂度优化
##### 复杂度分析
###### 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
###### 空间复杂度：O(1)。
##### Golang实现
    func climbStairs(n int) int {
        if n <= 2 {
            return n
        }
    
        m1, m2, ret := 1, 2, 3
        for i := 3; i <= n; i++ {
            ret = m1 + m2
            m1, m2 = m2, ret
        }
    
        return ret
    }
***
#### 题目
##### 53. 最大子序和
#### 地址
##### https://leetcode-cn.com/problems/maximum-subarray/
#### 方法一：暴力法
##### 复杂度分析
###### 时间复杂度：O(n^2)。
###### 空间复杂度：O(1)。
##### Golang实现
    func maxSubArray(nums []int) int {
    	// 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值
        ret := math.MinInt64
    
        for i := 0; i < len(nums); i++ {
            sum := 0
            for j := i; j < len(nums); j++ {
                sum += nums[j]
                ret = max(ret, sum)
            }
        }
    
        return ret
    }
    
    func max(a, b int) int {
        if a > b {
            return a
        }
    
        return b
    }
#### 方法二：动态规划
##### 复杂度分析
###### 时间复杂度：O(n)。
###### 空间复杂度：O(n)。
##### Golang实现
    func maxSubArray(nums []int) int {
        // dp[i]表示nums中以nums[i]结尾的最大子序和
        dp := make([]int, len(nums))
        dp[0] = nums[0]
        ret := dp[0]
    
        for i := 1; i < len(nums); i++ {
            dp[i] = max(dp[i-1]+nums[i], nums[i])
            ret = max(ret, dp[i])
        }
    
        return ret
    }
    
    func max(a, b int) int {
        if a > b {
            return a
        }
    
        return b
    }
#### 方法三：动态规划，空间复杂度优化
##### 复杂度分析
###### 时间复杂度：O(n)。
###### 空间复杂度：O(1)。
##### Golang实现
    func maxSubArray(nums []int) int {
        // 因为只需要知道dp的前一项，我们用int代替一维数组
        dp := nums[0]
        ret := dp
    
        for i := 1; i < len(nums); i++ {
            dp = max(dp+nums[i], nums[i])
            ret = max(ret, dp)
        }
    
        return ret
    }
    
    func max(a, b int) int {
        if a > b {
            return a
        }
    
        return b
    }
#### 方法四：贪心
##### 复杂度分析
###### 时间复杂度：O(n)。
###### 空间复杂度：O(1)。
##### Golang实现
    func maxSubArray(nums []int) int {
        // 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值
        ret := math.MinInt64
        sum := 0
    
        for i := 0; i < len(nums); i++ {
            sum += nums[i]
            ret = max(ret, sum)
            // 如果sum < 0，重新开始找子序串
            if sum < 0 {
                sum = 0
            }
        }
    
        return ret
    }
    
    func max(a, b int) int {
        if a > b {
            return a
        }
    
        return b
    }
#### 方法五：分治
##### 复杂度分析
###### 时间复杂度：O(n log(n))。
###### 空间复杂度：O(log(n))。
##### Golang实现
    func maxSubArray(nums []int) int {
        return maxSubArrayHelper(&nums, 0, len(nums)-1)
    }
    
    func maxSubArrayHelper(nums *[]int, left, right int) int {
        if left == right {
            return (*nums)[left]
        }
    
    	mid := (left + right) >> 1
    	leftSum := maxSubArrayHelper(nums, left, mid)
    	// 注意这里应是mid + 1，否则left + 1 = right时，会无限循环
    	rightSum := maxSubArrayHelper(nums, mid+1, right)
    	midSum := findMaxCrossingSubarray(nums, left, mid, right)
    	ret := max(max(leftSum, rightSum), midSum)
    
    	return ret
    }
    
    func findMaxCrossingSubarray(nums *[]int, left, mid, right int) int {
    	leftSum := math.MinInt64
    	sum := 0
    	for i := mid; i >= left; i-- {
    		sum += (*nums)[i]
    		leftSum = max(leftSum, sum)
    	}
    
    	rightSum := math.MinInt64
    	sum = 0
    	// 注意这里i = mid + 1，避免重复用到 nums[i]
    	for i := mid + 1; i <= right; i++ {
    		sum += (*nums)[i]
    		rightSum = max(rightSum, sum) 
    	}
    
    	return leftSum + rightSum
    }
    
    func max(a, b int) int {
    	if a > b {
    		return a
    	}
    
    	return b
    }
***