***
#### 题目
##### 剑指 Offer 49. 丑数
#### 地址
##### https://leetcode-cn.com/problems/chou-shu-lcof/
#### 方法一：动态规划
##### 复杂度分析
###### 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
###### 空间复杂度：O(N) 长度为 N 的 dp 列表使用 O(N) 的额外空间。
##### Golang实现
    func nthUglyNumber(n int) int {
        ret := make([]int, n)
        ret[0] = 1
        i2, i3, i5 := 0, 0, 0
    
        for i := 1; i < n; i++ {
            ret[i] = min(ret[i2]*2, min(ret[i3]*3, ret[i5]*5))
    
            if ret[i] == ret[i2]*2 {
                i2++
            }
            if ret[i] == ret[i3]*3 {
                i3++
            }
            if ret[i] == ret[i5]*5 {
                i5++
            }
        }
    
        return ret[n-1]
    }
    
    func min(a, b int) int {
        if a > b {
            return b
        }
    
        return a
    }
***
#### 题目
##### 面试题 17.09. 第 k 个数
#### 地址
##### https://leetcode-cn.com/problems/get-kth-magic-number-lcci/
#### 方法一：动态规划
##### 复杂度分析
###### 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
###### 空间复杂度：O(N) 长度为 N 的 dp 列表使用 O(N) 的额外空间。
##### Golang实现
    func getKthMagicNumber(k int) int {
        ret := make([]int, k)
        ret[0] = 1
        i3, i5, i7 := 0, 0, 0
    
        for i := 1; i < k; i++ {
            ret[i] = min(ret[i3]*3, min(ret[i5]*5, ret[i7]*7))
    
            if ret[i] == ret[i3]*3 {
                i3++
            }
            if ret[i] == ret[i5]*5 {
                i5++
            }
            if ret[i] == ret[i7]*7 {
                i7++
            }
        }
    
        return ret[k-1]
    }
    
    func min(a, b int) int {
        if a > b {
            return b
        }
    
        return a
    }
***
#### 题目
##### 70. 爬楼梯
#### 地址
##### https://leetcode-cn.com/problems/climbing-stairs/
#### 方法一：数学公式（斐波那契数列的公式）
##### 复杂度分析
###### 时间复杂度：O(log n)
###### 空间复杂度：O(1)
##### Golang实现
    func climbStairs(n int) int {
        sqrt5 := math.Sqrt(5)
        fibN := math.Pow((1+sqrt5)/2, float64(n+1)) - math.Pow((1-sqrt5)/2, float64(n+1))
        return int(math.Round(fibN / sqrt5))
    }
#### 方法二：动态规划（斐波拉契数列 F(n) = F(n-1) + F(n-2) (n>=2, F(0) = 0, F(1) = 1)）
##### 复杂度分析
###### 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
###### 空间复杂度：O(N) 长度为 N 的 dp 列表使用 O(N) 的额外空间。
##### Golang实现
    func climbStairs(n int) int {
        if n <= 2 {
            return n
        }
    
        ret := make([]int, n)
        ret[0] = 1
        ret[1] = 2
        for i := 2; i < n; i++ {
            ret[i] = ret[i-1] + ret[i-2]
        }
    
        return ret[n-1]
    }
#### 方法三：动态规划，空间复杂度优化
##### 复杂度分析
###### 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
###### 空间复杂度：O(1)
##### Golang实现
    func climbStairs(n int) int {
        if n <= 2 {
            return n
        }
    
        m1, m2, ret := 1, 2, 3
        for i := 3; i <= n; i++ {
            ret = m1 + m2
            m1, m2 = m2, ret
        }
    
        return ret
    }
***