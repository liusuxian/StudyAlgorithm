***
#### 题目
##### 剑指 Offer 49. 丑数
#### 地址
##### https://leetcode-cn.com/problems/chou-shu-lcof/
#### 方法一：动态规划
##### 复杂度分析
- 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
- 空间复杂度：O(N) 长度为 N 的 dp 列表使用 O(N) 的额外空间。
##### Golang实现
``` go
func nthUglyNumber(n int) int {
    ret := make([]int, n)
    ret[0] = 1
    i2, i3, i5 := 0, 0, 0

    for i := 1; i < n; i++ {
        ret[i] = min(ret[i2]*2, min(ret[i3]*3, ret[i5]*5))

        if ret[i] == ret[i2]*2 {
            i2++
        }
        if ret[i] == ret[i3]*3 {
            i3++
        }
        if ret[i] == ret[i5]*5 {
            i5++
        }
    }

    return ret[n-1]
}

func min(a, b int) int {
    if a > b {
        return b
    }

    return a
}
```
***
#### 题目
##### 面试题 17.09. 第 k 个数
#### 地址
##### https://leetcode-cn.com/problems/get-kth-magic-number-lcci/
#### 方法一：动态规划
##### 复杂度分析
- 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
- 空间复杂度：O(N) 长度为 N 的 dp 列表使用 O(N) 的额外空间。
##### Golang实现
``` go
func getKthMagicNumber(k int) int {
    ret := make([]int, k)
    ret[0] = 1
    i3, i5, i7 := 0, 0, 0

    for i := 1; i < k; i++ {
        ret[i] = min(ret[i3]*3, min(ret[i5]*5, ret[i7]*7))

        if ret[i] == ret[i3]*3 {
            i3++
        }
        if ret[i] == ret[i5]*5 {
            i5++
        }
        if ret[i] == ret[i7]*7 {
            i7++
        }
    }

    return ret[k-1]
}

func min(a, b int) int {
    if a > b {
        return b
    }

    return a
}
```
***
#### 题目
##### 70. 爬楼梯
#### 地址
##### https://leetcode-cn.com/problems/climbing-stairs/
#### 方法一：数学公式（斐波那契数列的公式）
##### 复杂度分析
- 时间复杂度：O(log(n))。
- 空间复杂度：O(1)。
##### Golang实现
``` go
func climbStairs(n int) int {
    sqrt5 := math.Sqrt(5)
    fibN := math.Pow((1+sqrt5)/2, float64(n+1)) - math.Pow((1-sqrt5)/2, float64(n+1))
    return int(math.Round(fibN / sqrt5))
}
```
#### 方法二：动态规划（斐波拉契数列 F(n) = F(n-1) + F(n-2) (n>=2, F(0) = 0, F(1) = 1)）
##### 复杂度分析
- 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
- 空间复杂度：O(N) 长度为 N 的 dp 列表使用 O(N) 的额外空间。
##### Golang实现
``` go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }

    ret := make([]int, n)
    ret[0] = 1
    ret[1] = 2
    for i := 2; i < n; i++ {
        ret[i] = ret[i-1] + ret[i-2]
    }

    return ret[n-1]
}
```
#### 方法三：动态规划，空间复杂度优化
##### 复杂度分析
- 时间复杂度：O(N) 其中 N=n ，动态规划需遍历计算 dp 列表。
- 空间复杂度：O(1)。
##### Golang实现
``` go
func climbStairs(n int) int {
    if n <= 2 {
        return n
    }

    m1, m2, ret := 1, 2, 3
    for i := 3; i <= n; i++ {
        ret = m1 + m2
        m1, m2 = m2, ret
    }

    return ret
}
```
***
#### 题目
##### 53. 最大子序和
#### 地址
##### https://leetcode-cn.com/problems/maximum-subarray/
#### 方法一：暴力法
##### 复杂度分析
- 时间复杂度：O(n^2)。
- 空间复杂度：O(1)。
##### Golang实现
``` go
func maxSubArray(nums []int) int {
    // 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值
    ret := math.MinInt64

    for i := 0; i < len(nums); i++ {
        sum := 0
        for j := i; j < len(nums); j++ {
            sum += nums[j]
            ret = max(ret, sum)
        }
    }

    return ret
}

func max(a, b int) int {
    if a > b {
        return a
    }

    return b
}
```
#### 方法二：动态规划
##### 复杂度分析
- 时间复杂度：O(n)。
- 空间复杂度：O(n)。
##### Golang实现
``` go
func maxSubArray(nums []int) int {
    // dp[i]表示nums中以nums[i]结尾的最大子序和
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    ret := dp[0]

    for i := 1; i < len(nums); i++ {
        dp[i] = max(dp[i-1]+nums[i], nums[i])
        ret = max(ret, dp[i])
    }

    return ret
}

func max(a, b int) int {
    if a > b {
        return a
    }

    return b
}
```
#### 方法三：动态规划，空间复杂度优化
##### 复杂度分析
- 时间复杂度：O(n)。
- 空间复杂度：O(1)。
##### Golang实现
``` go
func maxSubArray(nums []int) int {
    // 因为只需要知道dp的前一项，我们用int代替一维数组
    dp := nums[0]
    ret := dp

    for i := 1; i < len(nums); i++ {
        dp = max(dp+nums[i], nums[i])
        ret = max(ret, dp)
    }

    return ret
}

func max(a, b int) int {
    if a > b {
        return a
    }

    return b
}
```
#### 方法四：贪心
##### 复杂度分析
- 时间复杂度：O(n)。
- 空间复杂度：O(1)。
##### Golang实现
``` go
func maxSubArray(nums []int) int {
    // 类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值
    ret := math.MinInt64
    sum := 0

    for i := 0; i < len(nums); i++ {
        sum += nums[i]
        ret = max(ret, sum)
        // 如果sum < 0，重新开始找子序串
        if sum < 0 {
            sum = 0
        }
    }

    return ret
}

func max(a, b int) int {
    if a > b {
        return a
    }

    return b
}
```
#### 方法五：分治
##### 复杂度分析
- 时间复杂度：O(n log(n))。
- 空间复杂度：O(log(n))。
##### Golang实现
``` go
func maxSubArray(nums []int) int {
    return maxSubArrayHelper(&nums, 0, len(nums)-1)
}

func maxSubArrayHelper(nums *[]int, left, right int) int {
    if left == right {
        return (*nums)[left]
    }

    mid := (left + right) >> 1
    leftSum := maxSubArrayHelper(nums, left, mid)
    // 注意这里应是mid + 1，否则left + 1 = right时，会无限循环
    rightSum := maxSubArrayHelper(nums, mid+1, right)
    midSum := findMaxCrossingSubarray(nums, left, mid, right)
    ret := max(max(leftSum, rightSum), midSum)

    return ret
}

func findMaxCrossingSubarray(nums *[]int, left, mid, right int) int {
    leftSum := math.MinInt64
    sum := 0
    for i := mid; i >= left; i-- {
        sum += (*nums)[i]
        leftSum = max(leftSum, sum)
    }

    rightSum := math.MinInt64
    sum = 0
    // 注意这里i = mid + 1，避免重复用到 nums[i]
    for i := mid + 1; i <= right; i++ {
        sum += (*nums)[i]
        rightSum = max(rightSum, sum)
    }

    return leftSum + rightSum
}

func max(a, b int) int {
    if a > b {
        return a
    }

    return b
}
```
***
#### 题目
##### 1143. 最长公共子序列
#### 地址
##### https://leetcode-cn.com/problems/longest-common-subsequence/
#### 方法一：动态规划
##### 复杂度分析
- 时间复杂度：O(m*n + m)，其中 m 和 n 分别为 text1 和 text2 的 长度。
- 空间复杂度：O(m*n)，其中 m 和 n 分别为 text1 和 text2 的 长度。
##### Golang实现
``` go
func longestCommonSubsequence(text1 string, text2 string) int {
    m, n := len(text1)+1, len(text2)+1
    dp := make([][]int, m)
    for i := range dp {
        dp[i] = make([]int, n)
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            if text1[i-1] == text2[j-1] {
                dp[i][j] = dp[i-1][j-1] + 1
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
            }
        }
    }

    return dp[m-1][n-1]
}

func max(a, b int) int {
    if a > b {
        return a
    }

    return b
}
```
***
#### 题目
##### 62. 不同路径
#### 地址
##### https://leetcode-cn.com/problems/unique-paths/
#### 方法一：动态规划（逆向推导）
##### 复杂度分析
- 时间复杂度：O(m*n + m)。
- 空间复杂度：O(m*n)。
##### Golang实现
``` go
func uniquePaths(m int, n int) int {
    dp := make([][]int, m) // 从 (i, j) 走到 end 的不同路径数
    for i := range dp {
        dp[i] = make([]int, n)
    }

    for i := m - 1; i >= 0; i-- {
        for j := n - 1; j >= 0; j-- {
            if i == m-1 || j == n-1 {
                dp[i][j] = 1
            } else {
                dp[i][j] = dp[i+1][j] + dp[i][j+1]
            }
        }
    }

    return dp[0][0]
}
```
#### 方法二：动态规划（正向推导）
##### 复杂度分析
- 时间复杂度：O(m*n + m)。
- 空间复杂度：O(m*n)。
##### Golang实现
``` go
func uniquePaths(m int, n int) int {
    dp := make([][]int, m) // 从 start 走到 (i, j) 的不同路径数
    for i := range dp {
        dp[i] = make([]int, n)
    }

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if i == 0 || j == 0 {
                dp[i][j] = 1
            } else {
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }

    return dp[m-1][n-1]
}
```
#### 方法三：动态规划（逆向推导）+ 空间优化
##### 复杂度分析
- 时间复杂度：O(m*n + n)。
- 空间复杂度：O(n)。
##### Golang实现
``` go
func uniquePaths(m int, n int) int {
    dp := make([]int, n)
    for i := range dp {
        dp[i] = 1
    }

    for i := m - 2; i >= 0; i-- {
        for j := n - 2; j >= 0; j-- {
            dp[j] += dp[j+1]
        }
    }

    return dp[0]
}
```
#### 方法四：动态规划（正向推导）+ 空间优化
##### 复杂度分析
- 时间复杂度：O(m*n + n)。
- 空间复杂度：O(n)。
##### Golang实现
``` go
func uniquePaths(m int, n int) int {
    dp := make([]int, n)
    for i := range dp {
        dp[i] = 1
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[j] += dp[j-1]
        }
    }

    return dp[n-1]
}
```
***
#### 题目
##### 63. 不同路径 II
#### 地址
##### https://leetcode-cn.com/problems/unique-paths-ii/
#### 方法一：动态规划
##### 复杂度分析
- 时间复杂度：O(m*n)。
- 空间复杂度：O(n)。
##### Golang实现
``` go
func uniquePathsWithObstacles(obstacleGrid [][]int) int {
    m := len(obstacleGrid)
    n := len(obstacleGrid[0])
    dp := make([]int, n)
    if obstacleGrid[0][0] == 0 {
        dp[0] = 1
    }

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if obstacleGrid[i][j] == 1 {
                dp[j] = 0
                continue
            }

            if j-1 >= 0 && obstacleGrid[i][j-1] == 0 {
                dp[j] += dp[j-1] // dp[i-1][j] + dp[i][j-1]
            }
        }
    }

    return dp[n-1]
}
```
***
#### 题目
##### 64. 最小路径和
#### 地址
##### https://leetcode-cn.com/problems/minimum-path-sum/
#### 方法一：动态规划
##### 复杂度分析
- 时间复杂度：O(m*n)。
- 空间复杂度：O(1)。
##### Golang实现
``` go
func minPathSum(grid [][]int) int {
    m := len(grid)
    n := len(grid[0])

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            if i == 0 && j == 0 {
                continue
            } else if i == 0 {
                grid[i][j] = grid[i][j-1] + grid[i][j]
            } else if j == 0 {
                grid[i][j] = grid[i-1][j] + grid[i][j]
            } else {
                grid[i][j] = min(grid[i-1][j], grid[i][j-1]) + grid[i][j]
            }
        }
    }

    return grid[m-1][n-1]
}

func min(a, b int) int {
    if a > b {
        return b
    }

    return a
}
```
***
#### 题目
##### 120. 三角形最小路径和
#### 地址
##### https://leetcode-cn.com/problems/triangle/
#### 方法一：递归（f(i, j) = min(f(i+1, j), f(i+1, j+1)) + triangle[i][j]）（超时）
##### 复杂度分析
###### 时间复杂度：O(2^n)。
###### 空间复杂度：O(n)。
##### Golang实现
``` go
func minimumTotal(triangle [][]int) int {
    return dfs(triangle, 0, 0)
}

func dfs(triangle [][]int, i, j int) int {
    if i == len(triangle)-1 {
        return triangle[i][j]
    }

    return min(dfs(triangle, i+1, j), dfs(triangle, i+1, j+1)) + triangle[i][j]
}

func min(a, b int) int {
    if a > b {
        return b
    }

    return a
}
```
#### 方法二：递归 + 记忆化
##### 复杂度分析
- 时间复杂度：O(N^2 + N)，N 为三角形的行数。
- 空间复杂度：O((M * N) + N)，M 为三角形每行的列数，N 为三角形的行数。
##### Golang实现
``` go
func minimumTotal(triangle [][]int) int {
    memo := make([][]int, len(triangle))
    for k := range memo {
        memo[k] = make([]int, k+1)
    }

    return dfs(memo, triangle, 0, 0)
}

func dfs(memo, triangle [][]int, i, j int) int {
    if i == len(triangle)-1 {
        return triangle[i][j]
    }
    if memo[i][j] != 0 {
        return memo[i][j]
    }

    memo[i][j] = min(dfs(memo, triangle, i+1, j), dfs(memo, triangle, i+1, j+1)) + triangle[i][j]
    return memo[i][j]
}

func min(a, b int) int {
    if a > b {
        return b
    }

    return a
}
```
#### 方法三：动态规划
##### 复杂度分析
- 时间复杂度：O((M * N) + N)，M 为三角形每行的列数，N 为三角形的行数。
- 空间复杂度：O(M * N)，M 为三角形每行的列数，N 为三角形的行数。
##### Golang实现
``` go
func minimumTotal(triangle [][]int) int {
    // dp[i][j] 表示从点 (i, j) 到底边的最小路径和。
    dp := make([][]int, len(triangle)+1)
    for k := range dp {
        dp[k] = make([]int, k+2)
    }
    // 从三角形的最后一行开始递推。
    for i := len(triangle) - 1; i >= 0; i-- {
        for j := 0; j <= i; j++ {
            dp[i][j] = min(dp[i+1][j], dp[i+1][j+1]) + triangle[i][j]
        }
    }

    return dp[0][0]
}

func min(a, b int) int {
    if a > b {
        return b
    }

    return a
}
```
#### 方法四：动态规划，空间优化
##### 复杂度分析
- 时间复杂度：O(M * N)，M 为三角形每行的列数，N 为三角形的行数。
- 空间复杂度：O(N)，N 为三角形的行数。
##### Golang实现
``` go
func minimumTotal(triangle [][]int) int {
    dp := make([]int, len(triangle)+1)
    for i := len(triangle) - 1; i >= 0; i-- {
        for j := 0; j <= i; j++ {
            dp[j] = min(dp[j], dp[j+1]) + triangle[i][j]
        }
    }

    return dp[0]
}

func min(a, b int) int {
    if a > b {
        return b
    }

    return a
}
```
***
#### 题目
##### 322. 零钱兑换
#### 地址
##### https://leetcode-cn.com/problems/coin-change/
#### 方法一：回溯
##### 复杂度分析
- 时间复杂度：O(N! + log(N))。
- 空间复杂度：O(N)。
##### Golang实现
``` go
func coinChange(coins []int, amount int) int {
    if amount == 0 {
        return 0
    }

    sort.Ints(coins)
    ret := math.MaxInt64
    backtrack(&coins, amount, len(coins), 0, &ret)

    if ret == math.MaxInt64 {
        return -1
    }

    return ret
}

func backtrack(coins *[]int, amount, index, count int, ret *int) {
    if amount == 0 {
        *ret = min(*ret, count)
        return
    }
    if index == 0 {
        return
    }

    for i := amount / (*coins)[index-1]; i >= 0 && i+count < *ret; i-- {
        backtrack(coins, amount-i*(*coins)[index-1], index-1, i+count, ret)
    }
}

func min(a, b int) int {
    if a > b {
        return b
    }

    return a
}
```
#### 方法二：广度优先遍历
##### 复杂度分析
- 时间复杂度：O((M * N) + log(N))，M 为 coins 的长度，N 为 amount 的数值。
- 空间复杂度：O(N)。
##### Golang实现
``` go
func coinChange(coins []int, amount int) int {
    if amount == 0 {
        return 0
    }

    sort.Ints(coins)
    queue := []int{amount}
    visited := make([]bool, amount+1)
    visited[amount] = true
    step := 0

    for len(queue) > 0 {
        for i := len(queue); i > 0; i-- {
            head := queue[0]
            queue = queue[1:]

            for _, coin := range coins {
                next := head - coin
                // 只要遇到 0，就找到了一个最短路径
                if next == 0 {
                    return step + 1
                }
                if next < 0 {
                    // 由于 coins 升序排序，后面的面值会越来越大，剪枝
                    break
                }
                if !visited[next] {
                    queue = append(queue, next)
                    visited[next] = true
                }
            }
        }
        step++
    }

    return -1
}
```
#### 方法三：动态规划
##### 复杂度分析
- 时间复杂度：O(S * n)，其中 S 是金额，n 是面额数。
- 空间复杂度：O(S)。数组 dp 需要开长度为总金额 S 的空间。
##### Golang实现
``` go
func coinChange(coins []int, amount int) int {
    dp := make([]int, amount+1)
    // 注意：因为要比较的是最小值，这个不可能的值就得赋值成为一个最大值
    for k := range dp {
        dp[k] = amount + 1
    }
    // 理解 dp[0] = 0 的合理性，单独一枚硬币如果能够凑出面值，符合最优子结构
    dp[0] = 0

    for i := 1; i <= amount; i++ {
        for _, coin := range coins {
            if coin <= i && dp[i-coin] != amount+1 {
                dp[i] = min(dp[i], dp[i-coin]+1)
            }
        }
    }

    if dp[amount] == amount+1 {
        return -1
    }

    return dp[amount]
}

func min(a, b int) int {
    if a > b {
        return b
    }

    return a
}
```
***